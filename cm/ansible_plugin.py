# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# pylint: disable=line-too-long
from ansible.errors import AnsibleError
from ansible.plugins.action import ActionBase
from ansible.utils.vars import merge_hash
import cm


MSG_NO_CONFIG = "There are no job related vars in inventory. It's mandatory for that module to have some info from context. During normal execution it runs with inventory and config.yaml generated by ADCM. Did you forget to pass them during debug? Bad Dobby!"
MSG_NO_CLUSTER_CONTEXT = "You are trying to change cluster state outside of cluster context. Cluster state can be changed in cluster's or service's actions only. Bad Dobby!"
MSG_NO_CLUSTER_CONTEXT2 = "You are trying to change service state outside of cluster context. Service state can be changed by service_name in cluster's actions only. Bad Dobby!"
MSG_NO_SERVICE_CONTEXT = "You are trying to change unnamed service's state outside of service context. Service state can be changed in service's actions only or in cluster's actions but with using service_name arg. Bad Dobby!"
MSG_MANDATORY_ARGS = "Type, key and value are mandatory. Bad Dobby!"
MSG_NO_ROUTE = "Incorrect combination of args. Bad Dobby!"


class ContextActionModule(ActionBase):

    TRANSFERS_FILES = False
    _VALID_ARGS = None
    _MANDATORY_ARGS = None

    def _wrap_call(self, func, *args):
        try:
            func(*args)
        except cm.errors.AdcmEx as e:
            return {'failed': True, 'msg': e.msg}
        return {'changed': True}

    def _check_mandatory(self):
        for arg in self._MANDATORY_ARGS:
            if arg not in self._task.args:
                raise AnsibleError(MSG_MANDATORY_ARGS)

    def _get_job_var(self, task_vars, name):
        try:
            return task_vars["job"][name]
        except KeyError:
            raise AnsibleError(MSG_NO_CLUSTER_CONTEXT)

    def _check_context(self, task_vars):
        if task_vars is None or "job" not in task_vars:
            raise AnsibleError(MSG_NO_CONFIG + str(task_vars))

    def _do_cluster(self, task_vars, context):
        raise NotImplementedError

    def _do_service_by_name(self, task_vars, context):
        raise NotImplementedError

    def _do_service(self, task_vars, context):
        raise NotImplementedError

    def _do_host(self, task_vars, context):
        raise NotImplementedError

    def run(self, tmp=None, task_vars=None):
        self._check_mandatory()
        self._check_context(task_vars)

        obj_type = self._task.args["type"]

        if obj_type == 'cluster':
            res = self._do_cluster(
                task_vars,
                {'cluster_id': self._get_job_var(task_vars, 'cluster_id')}
            )
        elif obj_type == "service" and "service_name" in self._task.args:
            res = self._do_service_by_name(
                task_vars,
                {'cluster_id': self._get_job_var(task_vars, 'cluster_id')}
            )
        elif obj_type == "service":
            res = self._do_service(
                task_vars,
                {
                    'cluster_id': self._get_job_var(task_vars, 'cluster_id'),
                    'service_id': self._get_job_var(task_vars, 'service_id')
                }
            )
        elif obj_type == "host":
            res = self._do_host(
                task_vars,
                {'host_id': self._get_job_var(task_vars, 'host_id')}
            )
        elif obj_type == "provider":
            res = self._do_provider(
                task_vars,
                {'provider_id': self._get_job_var(task_vars, 'provider_id')}
            )
        else:
            raise AnsibleError(MSG_NO_ROUTE)

        result = super().run(tmp, task_vars)
        return merge_hash(result, res)
